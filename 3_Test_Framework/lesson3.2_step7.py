Составные сообщения об ошибках 
Отдельно хочется поговорить про качество сообщений об ошибках, которые показываются при падении теста. Почему это важно? Хорошо написанный текст помогает быстро локализовать найденный баг и разобраться в том, что произошло и из-за чего тест упал. Хороший assert сэкономит вам часы вашей работы, особенно когда количество тестов переходит за сотню.

В целом, тут как с любым фидбеком: важно давать его точно и актуально. Если вы проверяете наличие элемента, то обязательно пишите, что это за элемент по смыслу на странице: 

assert self.is_element_present('create_class_button', timeout=30), "No create class button"
Примечание: Функция is_element_present() вспомогательная. Как её реализовать и использовать, мы разберемся чуть позжe.

Если элемент встречается на нескольких страницах приложения, не лишним будет указать, где именно произошла ошибка: 

assert self.is_element_present('new_announcement_button', timeout=30), "No new announcement button on profile page"
Если вы работаете с каким-то текстом (например, проверяете информационное сообщение, текущий url, ссылку, placeholder в input-элементе или любой другой текст), в сообщении об ошибке всегда лучше выводить оба значения: то, которое ожидалось, и то, которое получили по факту. Всё как в хорошем багрепорте: ожидаемый и фактический результат.

В питоне такое можно провернуть с помощью конкатенации строк, например:

"Wrong text, got" + actual_result + ", something wrong"
Но из-за обилия кавычек, знаков сложения и вот этого всего этот способ не самый удобный и читается тоже плохо.

Гораздо лучше воспользоваться возможностью python для форматирования строк. Дополнительно можно почитать здесь: https://realpython.com/python-string-formatting/#2-new-style-string-formatting-strformat

Если вкратце, то python умеет подставлять пользовательские значения в строки с помощью функции .format(). Синтаксис выглядит примерно так:

"Let's count together! {}, then goes {}, and then {}".format("one", "two", "three")
Попробуйте запустить её в интерпретаторе. Такая строка при исполнении кода превратится в: 

Let's count together! one, then goes two, and then three
Таким образом мы можем удобно компоновать ожидаемое и фактическое значение в одну строку.

Еще один важный момент: когда вы работаете с текстом элементов на странице или любым другим контентом, который может измениться, всегда записывайте его в отдельную переменную для сравнения. 

неправильно: 

assert self.catalog_link.text  == "Каталог", \
    "Wrong language, got" + self.catalog_link.text + "instead of 'Каталог'" 
Дважды считывать атрибут — это плохая практика, потому что при повторном считывании текст на странице может измениться, и вы получите неактуальный текст об ошибке. Результат выполнения такого теста сложно анализировать: 

"Wrong language, got 'Каталог' instead of 'Каталог'"
правильно: 

catalog_text = self.catalog_link.text # считываем текст и записываем его в переменную
assert catalog_text == "Каталог", \
    "Wrong language, got" + catalog_text + "instead of 'Каталог'" 


# "Let's count together! {}, then goes {}, and then {}".format("one", "two", "three")
# f"Wrong text, got {actual_result}, something wrong"  #важно! версия python >= 3.6
#Лучше использовать f-string вместо .format()

# f"Wrong text, got {actual_result}, something wrong"  
# важно! версия python >= 3.6
# Лучше использовать f-string вместо .format()
# начинали делать курс, когда f-string еще не работали :) Потом обновим теорию
